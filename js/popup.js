// Import i18n manager
import i18n from './i18n.js';

// Toast æç¤ºå‡½æ•°
function showToast(message, duration = 3000) {
  // ç§»é™¤å·²å­˜åœ¨çš„ toast
  const existingToast = document.querySelector('.toast');
  if (existingToast) {
    existingToast.remove();
  }

  // åˆ›å»º toast å…ƒç´ 
  const toast = document.createElement('div');
  toast.classList.add('toast');
  toast.textContent = message;

  // æ·»åŠ åˆ° body
  document.body.appendChild(toast);

  // è‡ªåŠ¨ç§»é™¤
  setTimeout(() => {
    toast.classList.add('toast-fade-out');
    setTimeout(() => {
      if (toast.parentNode) {
        toast.remove();
      }
    }, 300);
  }, duration);
}

document.addEventListener("DOMContentLoaded", async () => {

  const searchInput = document.getElementById("search-input");
  const tabList = document.getElementById("tab-list");
  let tabsCount = document.getElementById("tab-count");

  // å½“å‰é€‰ä¸­çš„tab item
  let selectedIndex = -1;
  // æ ‡ç­¾åˆ—è¡¨
  let lis = tabList.childNodes;
  // æ ‡ç­¾Idä¸åˆ—è¡¨ç´¢å¼•idçš„å¯¹åº”å…³ç³»
  let tabIdMap = new Map();

  // å­åºåˆ—åŒ¹é…å‡½æ•°ï¼šæ£€æŸ¥ keyword æ˜¯å¦æ˜¯ text çš„å­åºåˆ—
  // ä¾‹å¦‚ï¼š"spb" æ˜¯ "spring boot" çš„å­åºåˆ—
  function subsequenceMatch(keyword, text) {
    if (keyword.length === 0) return true;
    if (text.length === 0) return false;
    
    let keywordIndex = 0;
    
    for (let i = 0; i < text.length && keywordIndex < keyword.length; i++) {
      if (text[i] === keyword[keywordIndex]) {
        keywordIndex++;
      }
    }
    
    return keywordIndex === keyword.length;
  }

  // é«˜äº®åŒ¹é…çš„å­—ç¬¦
  function highlightMatches(text, keywords) {
    if (!keywords || keywords.length === 0) {
      return text;
    }

    // åˆ›å»ºä¸€ä¸ªæ ‡è®°æ•°ç»„ï¼Œè®°å½•æ¯ä¸ªå­—ç¬¦æ˜¯å¦è¢«åŒ¹é…
    const matched = new Array(text.length).fill(false);
    const lowerText = text.toLowerCase();
    
    // å¯¹æ¯ä¸ªå…³é”®å­—è¿›è¡ŒåŒ¹é…
    keywords.forEach(keyword => {
      let keywordIndex = 0;
      for (let i = 0; i < text.length && keywordIndex < keyword.length; i++) {
        if (lowerText[i] === keyword[keywordIndex]) {
          matched[i] = true;
          keywordIndex++;
        }
      }
    });

    // æ„å»ºé«˜äº®çš„ HTML
    let result = '';
    for (let i = 0; i < text.length; i++) {
      if (matched[i]) {
        result += `<span class="highlight">${text[i]}</span>`;
      } else {
        result += text[i];
      }
    }

    return result;
  }

  // ç„¦ç‚¹é»˜è®¤å®šä½åˆ°æœç´¢è¾“å…¥æ¡†
  searchInput.focus();

  // Function to update the displayed tabs based on search input
  async function updateTabs(nextSelectedTabId) {
    const query = searchInput.value.trim().toLowerCase();
    
    // ä½¿ç”¨ Promise åŒ…è£… chrome.tabs.query
    const tabs = await new Promise((resolve) => {
      chrome.tabs.query({}, resolve);
    });
    let filteredTabs;
    
    // æŒ‰ç©ºæ ¼åˆ†å‰²æŸ¥è¯¢å­—ç¬¦ä¸²ï¼Œå¾—åˆ°å¤šä¸ªå…³é”®å­—
    const keywords = query.split(/\s+/).filter(kw => kw.length > 0);
    
    if (!query || keywords.length === 0) {
      // å¦‚æœæŸ¥è¯¢ä¸ºç©ºæˆ–æ²¡æœ‰æœ‰æ•ˆå…³é”®å­—ï¼Œåˆ™è¿”å›æ‰€æœ‰æ ‡ç­¾é¡µ
      filteredTabs = tabs;
    } else {
      // è¿‡æ»¤æ ‡ç­¾é¡µï¼Œç¡®ä¿æ ‡é¢˜åŒ…å«æ‰€æœ‰å…³é”®å­—ï¼ˆä½¿ç”¨å­åºåˆ—åŒ¹é…ï¼‰
      filteredTabs = tabs.filter((tab) => {
        const lowerTitle = tab.title.toLowerCase();
        return keywords.every(keyword => subsequenceMatch(keyword, lowerTitle));
      });
    }

    tabList.innerHTML = "";
    tabIdMap.clear();

    // tabList index
    let i = 0;

    // populate the tab list with the filtered tabs
    for (const tab of filteredTabs) {
        try {
          const li = document.createElement("li");

          // tab icon
          const icon = document.createElement('img');
          icon.classList.add("li-icon");
          icon.src = faviconURL(tab.url);

          const listItemDiv = document.createElement("div");
          listItemDiv.classList.add("li-item");

          // create elements for tab title and URL info
          const titleDiv = document.createElement("div");
          titleDiv.classList.add("tab-title");
          
          // é«˜äº®åŒ¹é…çš„å­—ç¬¦
          if (keywords.length > 0) {
            titleDiv.innerHTML = highlightMatches(tab.title, keywords);
          } else {
            titleDiv.textContent = tab.title;
          }

          const urlHostNameDiv = document.createElement("div");
          urlHostNameDiv.classList.add("tab-url-hostname");
          urlHostNameDiv.textContent = new URL(tab.url).hostname;
          const lastElement = tab.url.substring(tab.url.lastIndexOf('/') + 1);
          if (lastElement.length > 0) {
            urlHostNameDiv.textContent = urlHostNameDiv.textContent + "/.../" + lastElement;
          }
          urlHostNameDiv.title = tab.url;


          listItemDiv.appendChild(titleDiv);
          listItemDiv.appendChild(urlHostNameDiv);

          // åˆ›å»ºæ“ä½œæŒ‰é’®å®¹å™¨
          const actionContainer = document.createElement("div");
          actionContainer.classList.add("action-container");
          
          // æ£€æŸ¥æ ‡ç­¾é¡µæ˜¯å¦å·²å›ºå®š
          const isPinned = await isTabPinned(tab.id);
          
          // åˆ›å»ºå›ºå®š/å–æ¶ˆå›ºå®šæŒ‰é’®
          const pinBtn = document.createElement("button");
          pinBtn.classList.add("action-btn", "pin-btn");
          if (isPinned) {
            pinBtn.innerHTML = "ğŸ“Œ";
            pinBtn.title = i18n.getMessage('unpinTab') || 'å–æ¶ˆå›ºå®šæ ‡ç­¾é¡µ';
          } else {
            pinBtn.innerHTML = "ğŸ“Œ";
            pinBtn.title = i18n.getMessage('pinToFavorites') || 'å›ºå®šåˆ°å¸¸ç”¨åˆ—è¡¨';
          }
          pinBtn.style.opacity = "0";
          pinBtn.style.visibility = "hidden";
          pinBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            handlePinTab(tab);
          });
          
          // åˆ›å»ºå…³é—­æŒ‰é’®
          const closeBtn = document.createElement("button");
          closeBtn.classList.add("action-btn", "close-btn");
          closeBtn.innerHTML = "âœ•";
          closeBtn.title = i18n.getMessage('closeTab') || 'Close tab';
          closeBtn.style.opacity = "0";
          closeBtn.style.visibility = "hidden";
          closeBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            handleCloseBtnClicked(tab.id);
          });
          
          // åˆ›å»ºä¸‰ç‚¹æŒ‰é’®ï¼ˆå§‹ç»ˆå¯è§ï¼‰
          const menuBtn = document.createElement("button");
          menuBtn.classList.add("action-btn", "menu-btn");
          menuBtn.innerHTML = "â‹¯";
          menuBtn.title = i18n.getMessage('menuLabel') || 'èœå•';
          menuBtn.style.opacity = "0";
          menuBtn.style.visibility = "hidden";
          
          // ç»„è£…æŒ‰é’®å®¹å™¨
          actionContainer.appendChild(pinBtn);
          actionContainer.appendChild(closeBtn);
          actionContainer.appendChild(menuBtn);

          li.appendChild(icon);
          li.appendChild(listItemDiv);
          li.appendChild(actionContainer);

          // å¤„ç†æŒ‰é’®æ˜¾ç¤º/éšè— - æ‚¬åœæ ‡ç­¾é¡¹æ—¶æ˜¾ç¤ºæ‰€æœ‰æŒ‰é’®
          li.addEventListener("mouseenter", function () {
            pinBtn.style.opacity = "1";
            pinBtn.style.visibility = "visible";
            closeBtn.style.opacity = "1";
            closeBtn.style.visibility = "visible";
            menuBtn.style.opacity = "1";
            menuBtn.style.visibility = "visible";
          });
          
          li.addEventListener("mouseleave", function (e) {
            // åªæœ‰å½“é¼ æ ‡çœŸæ­£ç¦»å¼€ li å…ƒç´ æ—¶æ‰éšè—ï¼ˆä¸æ˜¯ç§»åŠ¨åˆ°å­å…ƒç´ ï¼‰
            if (!li.contains(e.relatedTarget)) {
              pinBtn.style.opacity = "0";
              pinBtn.style.visibility = "hidden";
              closeBtn.style.opacity = "0";
              closeBtn.style.visibility = "hidden";
              menuBtn.style.opacity = "0";
              menuBtn.style.visibility = "hidden";
            }
          });

          // add click event to switch to the selected tab
          li.addEventListener("click", function () {
            chrome.tabs.get(tab.id, (tab) => {
              if (chrome.runtime.lastError) {
                const errorMessage = i18n.getMessage('errorGetTabInfo', chrome.runtime.lastError.message);
                console.warn(errorMessage || `Failed to get tab information: ${chrome.runtime.lastError.message}`);
                window.close();
                return;
              }

              const windowId = tab.windowId;
              // åªå‘é€æ¶ˆæ¯ç»™ background.js å¤„ç†
              chrome.runtime.sendMessage({
                action: "switchToTab",
                data: {
                  tabId: tab.id,
                  windowId: windowId
                }
              });
              window.close();
            });
          });

          tabList.appendChild(li);
          tabIdMap.set(i++, tab.id);
        } catch (error) {
          // å¦‚æœtryå—ä¸­æŠ›å‡ºé”™è¯¯ï¼Œè¿™é‡Œå°†æ•è·åˆ°é”™è¯¯
          // console.error("An error occurred:", error.message);
        }
      }
      lis = tabList.childNodes;

      // é»˜è®¤é€‰ä¸­ï¼Œæ–¹ä¾¿enterç›´æ¥è·³è½¬
      if (lis.length > 0) {
        if (nextSelectedTabId !== 'undefined' && nextSelectedTabId >= 0) {
          selectedIndex = nextSelectedTabId;
          lis[selectedIndex].classList.add("selected");
        } else {
          lis[0].classList.add("selected");
          selectedIndex = 0;
        }
      }

      // å·²æ‰“å¼€æ ‡ç­¾æ€»æ•°å±•ç¤ºæ§åˆ¶
      if (query.length === 0) {
        chrome.tabs.query({windowType: 'normal'}, function (allTabs) {
          const message = i18n.getMessage('tabsCount', allTabs.length.toString());
          tabsCount.textContent = message ? message.replace('$COUNT$', allTabs.length) : `${allTabs.length} Tabs`;
        });
      } else {
        const message = i18n.getMessage('tabsCount', filteredTabs.length.toString());
        tabsCount.textContent = message ? message.replace('$COUNT$', filteredTabs.length) : `${filteredTabs.length} Tabs`;
      }
  }

  function faviconURL(u) {
    const url = new URL(chrome.runtime.getURL("/_favicon/"));
    url.searchParams.set("pageUrl", u);
    url.searchParams.set("size", "26");
    return url.toString();
  }

  // å›ºå®šæ ‡ç­¾é¡µå®¹é‡é™åˆ¶
  const MAX_PINNED_TABS = 5;

  // æ£€æŸ¥æ ‡ç­¾é¡µæ˜¯å¦å·²å›ºå®š
  async function isTabPinned(tabId) {
    const result = await new Promise((resolve) => {
      chrome.storage.sync.get('pinnedTabs', resolve);
    });
    const pinnedTabs = result.pinnedTabs || [];
    return pinnedTabs.some(tab => tab.tabId === tabId);
  }

  // æ·»åŠ æ ‡ç­¾é¡µåˆ°å›ºå®šåˆ—è¡¨
  async function pinTab(tab) {
    try {
      const result = await new Promise((resolve) => {
        chrome.storage.sync.get('pinnedTabs', resolve);
      });
      let pinnedTabs = result.pinnedTabs || [];
      
      // æ£€æŸ¥æ˜¯å¦å·²å›ºå®š
      if (pinnedTabs.some(t => t.tabId === tab.id)) {
        return { success: true, message: 'å·²å›ºå®š' };
      }
      
      // æ£€æŸ¥å®¹é‡é™åˆ¶
      if (pinnedTabs.length >= MAX_PINNED_TABS) {
        return { success: false, message: i18n.getMessage('pinnedTabsLimit', MAX_PINNED_TABS.toString()) || `å›ºå®šæ ‡ç­¾é¡µæ•°é‡è¶…è¿‡${MAX_PINNED_TABS}ä¸ªçš„é™åˆ¶` };
      }
      
      // æ·»åŠ åˆ°å›ºå®šåˆ—è¡¨
      pinnedTabs.push({
        tabId: tab.id,
        title: tab.title,
        url: tab.url,
        icon: faviconURL(tab.url)
      });
      
      // ä¿å­˜åˆ°å­˜å‚¨
      await new Promise((resolve) => {
        chrome.storage.sync.set({ pinnedTabs }, resolve);
      });
      
      return { success: true, message: 'å›ºå®šæˆåŠŸ' };
    } catch (error) {
      console.error('Error pinning tab:', error);
      return { success: false, message: 'å›ºå®šå¤±è´¥' };
    }
  }

  // ä»å›ºå®šåˆ—è¡¨ä¸­ç§»é™¤
  async function unpinTab(tabId) {
    try {
      const result = await new Promise((resolve) => {
        chrome.storage.sync.get('pinnedTabs', resolve);
      });
      let pinnedTabs = result.pinnedTabs || [];
      
      // è¿‡æ»¤æ‰è¦ç§»é™¤çš„æ ‡ç­¾é¡µ
      pinnedTabs = pinnedTabs.filter(tab => tab.tabId !== tabId);
      
      // ä¿å­˜åˆ°å­˜å‚¨
      await new Promise((resolve) => {
        chrome.storage.sync.set({ pinnedTabs }, resolve);
      });
      
      return { success: true, message: 'å–æ¶ˆå›ºå®šæˆåŠŸ' };
    } catch (error) {
      console.error('Error unpinning tab:', error);
      return { success: false, message: 'å–æ¶ˆå›ºå®šå¤±è´¥' };
    }
  }

  // å¤„ç†List item å…³é—­æ ‡ç­¾äº‹ä»¶
  function handleCloseBtnClicked(tabId) {
    if (tabId !== undefined) {
      chrome.tabs.remove(tabId, () => {
        if (chrome.runtime.lastError) {
          const errorMessage = i18n.getMessage('closeTabFailed', chrome.runtime.lastError.message);
          console.warn(errorMessage || `Failed to close tab: ${chrome.runtime.lastError.message}`);
          return;
        }
        let nextTabId;
        if (selectedIndex >= 0) {
          nextTabId = selectedIndex - 1;
        } else {
          nextTabId = -1;
        }
        updateTabs(nextTabId);
      });
    }
  }

  // å¤„ç†å›ºå®š/å–æ¶ˆå›ºå®šäº‹ä»¶
  async function handlePinTab(tab) {
    const isPinned = await isTabPinned(tab.id);
    let result;
    
    if (isPinned) {
      result = await unpinTab(tab.id);
    } else {
      result = await pinTab(tab);
    }
    
    // æ˜¾ç¤ºæç¤º
    if (!result.success) {
      showToast(result.message);
    } else {
      // æ“ä½œæˆåŠŸï¼Œæ›´æ–°åˆ—è¡¨æ˜¾ç¤º
      updateTabs(selectedIndex);
    }
  }

  function updateSelection() {
    if (lis.length > 0 && selectedIndex === -1) {
      lis[0].classList.add("selected");
      selectedIndex = 0;
    }
    lis.forEach((li, index) => {
      if (index === selectedIndex) {
        li.classList.add("selected");
      } else {
        li.classList.remove("selected");
      }
    });
  }

  function handleEnterButtonEvent() {
    let tabId = tabIdMap.get(selectedIndex);
    if (tabId !== undefined) {
      chrome.tabs.get(tabId, (tab) => {
        const windowId = tab.windowId;
        // åªå‘é€æ¶ˆæ¯ç»™ background.js å¤„ç†
        chrome.runtime.sendMessage({
          action: "switchToTab",
          data: {
            tabId: tabId,
            windowId: windowId
          }
        });
        window.close();
      });
    }
  }

  function handleDeleteButtonEvent() {
    let tabId = tabIdMap.get(selectedIndex);
    if (tabId !== undefined) {
      handleCloseBtnClicked(tabId);
    }
  }

  function scrollIntoView(selectedIndex, event, behavior) {
    event.preventDefault();
    if (lis.length === 0) {
      return;
    }
    const selectedItem = lis[selectedIndex];
    
    if (!selectedItem) {
      return;
    }
    
    // behaviorå‚æ•°æ§åˆ¶æ˜¯å¦å¹³æ»‘æ»šåŠ¨
    const scrollBehavior = behavior === undefined ? 'smooth' : behavior;
    
    // ä½¿ç”¨Element.scrollIntoView()æ–¹æ³•ï¼Œè¿™æ˜¯ä¸€ä¸ªæ›´å¯é çš„æ–¹æ³•ã€‚ç¡®ä¿å…ƒç´ æ»šåŠ¨åˆ°å¯è§†åŒºåŸŸ
    selectedItem.scrollIntoView({
      block: 'nearest',  // åªåœ¨å¿…è¦æ—¶æ»šåŠ¨ï¼Œå°½é‡ä¿æŒå…ƒç´ åœ¨è§†å›¾å†…
      behavior: scrollBehavior
    });
  }

  window.addEventListener("keydown", function (event) {
    if (event.key === "ArrowUp") {
      if (selectedIndex <= 0) {
        selectedIndex = lis.length - 1; // å¦‚æœå·²ç»åœ¨é¡¶éƒ¨ï¼Œåˆ™è·³è½¬åˆ°åº•éƒ¨
      } else {
        selectedIndex--;
      }
      updateSelection();
      scrollIntoView(selectedIndex, event);
    } else if (event.key === "ArrowDown") {
      if (selectedIndex >= lis.length - 1) {
        selectedIndex = 0; // å¦‚æœå·²ç»åœ¨åº•éƒ¨ï¼Œåˆ™è·³è½¬åˆ°é¡¶éƒ¨
      } else {
        selectedIndex++;
      }
      updateSelection();
      scrollIntoView(selectedIndex, event);
    } else if (event.key === "Enter") {
      handleEnterButtonEvent();
    } else if (event.key === "Delete") {
      handleDeleteButtonEvent();
      scrollIntoView(selectedIndex, event, 'auto');
    }
  });

  // Set up i18n for UI elements
  function setupI18n() {
    // Set placeholder and aria-label for search input
    searchInput.placeholder = i18n.getMessage('searchPlaceholder') || 'æœç´¢å·²æ‰“å¼€çš„æ ‡ç­¾é¡µ...';
    searchInput.setAttribute('aria-label', i18n.getMessage('ariaLabelSearch') || 'æœç´¢å·²æ‰“å¼€çš„æ ‡ç­¾é¡µ');
  }

  // Initialize i18n
  await i18n.initialize();
  
  // Set initial loading text with i18n
  tabsCount.textContent = i18n.getMessage('loadingText') || 'Loading...';
  
  // initial tab update
  updateTabs();
  
  // Set up i18n after DOM is loaded
  setupI18n();
  
  // event listener for search input changes
  searchInput.addEventListener("input", updateTabs);
  
  // Add language change listener
  i18n.addListener(() => {
    setupI18n();
    updateTabs();
  });
  
  // Listen for language change messages from other parts
  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'languageChanged') {
      // Update i18n language
      i18n.setLanguage(message.language).then(() => {
        // Reapply i18n after language change
        setupI18n();
        updateTabs();
      });
    }
  });
});